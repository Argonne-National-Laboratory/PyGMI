from PySide.QtGui import QWidget,QApplication
from PySide.QtCore import QTimer
#import the interface design generated by Qt designer
import Lakeshore340_Ui


class Panel(QWidget):
    def __init__(self,parent=None,instr=None,lock=None,title='Instrument Panel'):
        # This class derivates from a Qt Widget so we have to call
        # the class builder ".__init__()"
        QWidget.__init__(self)
        # "self" is now a Qt Widget, then we load the user interface
        # generated with QtDesigner and call it self.ui
        self.ui = Lakeshore340_Ui.Ui_Panel()
        # Now we have to feed the GUI building method of this object (self.ui)
        # with the current Qt Widget 'self', but the widgets from the design will actually be built as children
        # of the object self.ui
        self.ui.setupUi(self)
        self.setWindowTitle(title)
        self.reserved_access_to_instr=lock
        self.temp_controller=instr
        
        self.check_T_timer = QTimer()
        self.check_T_timer.setSingleShot(True)#The timer would not wait for the completion of the task otherwise
        self.check_T_timer.timeout.connect(self.autocheckT)
        
        if self.ui.checkTbox.isChecked():self.autocheckT()
    
    def checkT(self):
        with self.reserved_access_to_instr:
            T=self.temp_controller.query_temp(self.ui.temp_controller_channel.currentText())
        self.ui.T_display.setText(str(T)+" K")
    
    def autocheckT(self,state=1):
        if state:
            self.checkT()
            self.check_T_timer.start(self.ui.refresh_rate.value()*1000)#The value must be converted to milliseconds
        else:
            self.check_T_timer.stop()
    
    def update_timer_timeout(self,secs):
       self.check_T_timer.setInterval(int(secs*1000))
    
    def set_heater_range(self,value=0):
        if value in range(6): #check compatibility
            with self.reserved_access_to_instr:
                self.temp_controller.set_heater_range(value)
        
    def set_setpoint(self):
        loop=self.ui.temp_controller_loop.value()
        setpoint=self.ui.temp_controller_setpoint.value()
        with self.reserved_access_to_instr:
            #self.temp_controller.switch_ramp(loop,'off')
            self.temp_controller.set_setpoint(loop,setpoint)
        
    def stop_ramp(self):
        loop=self.ui.temp_controller_loop.value()
        with self.reserved_access_to_instr:            
            self.temp_controller.switch_ramp(loop,'off')
                
    def init_ramp(self):
        """After this function is called, the ramp will start the next time the setpoint is changed """
        loop=self.ui.temp_controller_loop.value()
        #setpoint=self.ui.temp_controller_setpoint.value()
        rate=self.ui.temp_controller_ramprate.value()
        with self.reserved_access_to_instr:            
            #self.temp_controller.set_setpoint(loop,setpoint)
            self.temp_controller.conf_ramp(loop,rate,'on')
                
    def PID_P_update(self,new_P_value):
        with self.reserved_access_to_instr:
            P,I,D=self.temp_controller.query_PID(1)            
            self.temp_controller.set_PID(1,new_P_value,I,D)

    def PID_I_update(self,new_I_value):
        with self.reserved_access_to_instr:
            P,I,D=self.temp_controller.query_PID(1)            
            self.temp_controller.set_PID(1,P,new_I_value,D)
            
    def PID_D_update(self,new_D_value):
        with self.reserved_access_to_instr:
            P,I,D=self.temp_controller.query_PID(1)            
            self.temp_controller.set_PID(1,P,I,new_D_value)
    

    
    
if __name__ == "__main__":
    import sys
    app = QApplication(sys.argv)
    window = Panel(app)
    window.show()
    sys.exit(app.exec_())
