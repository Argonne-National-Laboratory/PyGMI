from PyQt5.QtWidgets import QWidget,QApplication
from PyQt5.QtCore import QTimer
#import the interface design generated by Qt designer
from . import SR830_Ui


class Panel(QWidget):
    def __init__(self,parent=None,instr=None,lock=None,title='Instrument Panel'):
        # This class derivates from a Qt Widget so we have to call
        # the class builder ".__init__()"
        QWidget.__init__(self)
        # "self" is now a Qt Widget, then we load the user interface
        # generated with QtDesigner and call it self.ui
        self.ui = SR830_Ui.Ui_Panel()
        # Now we have to feed the GUI building method of this object (self.ui)
        # with the current Qt Widget 'self', but the widgets from the design will actually be built as children
        # of the object self.ui
        self.ui.setupUi(self)
        self.setWindowTitle(title)
        self.reserved_access_to_instr=lock
        self.instr=instr
        self.monitor_timer = QTimer()
        self.channel=self.ui.channel.currentIndex()
        #The timer would not wait for the completion of the task otherwise
        self.monitor_timer.setSingleShot(True)
        self.monitor_timer.timeout.connect(self.monitor)
        self.firsttime=0
        #bug: if the box is checked in the .ui file, the system freezes
        #if self.ui.monitor.isChecked():self.monitor()
    
    def update_boxes(self):
        with self.reserved_access_to_instr:
            #There are two signals emitted if the current item of a combobox changes,
            #PySide.QtGui.QComboBox.currentIndexChanged() and PySide.QtGui.QComboBox.activated().
            #PySide.QtGui.QComboBox.currentIndexChanged() is always emitted regardless 
            #if the change was done programmatically or by user interaction,
            #while PySide.QtGui.QComboBox.activated() is only emitted when the change is caused by user interaction.
            self.ui.sense.setCurrentIndex(self.instr.query_sensitivity())
            self.ui.TC.setCurrentIndex(self.instr.query_time_cste())
            self.ui.filter.setCurrentIndex(self.instr.query_filter_slop())
            self.ui.channel.setCurrentIndex(self.instr.query_ch1_display())
            self.ch1=self.ui.channel.currentText()
            self.ui.channel_2.setCurrentIndex(self.instr.query_ch2_display())
            self.ch2=self.ui.channel_2.currentText()
            self.ui.ref_source.setCurrentIndex(self.instr.query_ref_mode())
    

    def monitor(self,state=1):
        if state!=1:
            self.monitor_timer.stop()
            self.firsttime=0
        elif state and not(self.monitor_timer.isActive()):
            self.firsttime+=1
            if self.firsttime==1:self.update_boxes()
            with self.reserved_access_to_instr:
                x,y=self.instr.query_ch1_ch2(self.ch1,self.ch2)
                self.ui.x_disp.setText(str(x))
                self.ui.y_disp.setText(str(y))
                self.ui.f_disp.setText(str(self.instr.query_frequency())+' Hz')
                self.ui.a_disp.setText(str(self.instr.query_amplitude())+' V')
                self.ui.ph_disp.setText(str(self.instr.query_phase())+' deg')
            self.monitor_timer.start(self.ui.refresh_rate.value()*1000)
        
    
    def update_timer_timeout(self,secs):
        #The value must be converted to milliseconds            
        self.monitor_timer.setInterval(secs*1000)
    
    def change_f(self,value=0):
        with self.reserved_access_to_instr:
            self.instr.set_frequency(value)                
                
    def change_A(self,value=0):
        with self.reserved_access_to_instr:                
            self.instr.set_amplitude(value)                

    def change_ph(self,value=0):
        with self.reserved_access_to_instr:
            self.instr.set_amplitude(value)              

    def change_x(self,value):
        with self.reserved_access_to_instr:
            self.instr.set_ch1_display(value)
            self.ch1=value#self.instr.query_ch1_display()
    
    def change_y(self,value):
        with self.reserved_access_to_instr:
            self.instr.set_ch2_display(value)
            self.ch2=value#self.instr.query_ch2_display()

    def change_s(self,value=0):
        with self.reserved_access_to_instr:
            self.instr.set_sensitivity(value)

    def change_TC(self,value=0):
        with self.reserved_access_to_instr:
            self.instr.set_time_cste(value)

    def change_filter(self,value=0):
        with self.reserved_access_to_instr:
            self.instr.set_filter_slop(value)
    
    def change_ref(self,value='Internal'):
        with self.reserved_access_to_instr:
            self.instr.set_ref_mode(value)
        
    
if __name__ == "__main__":
    import sys
    app = QApplication(sys.argv)
    window = Panel(app)
    window.show()
    sys.exit(app.exec_())
